const bsvMessage = (function(t) {
  const r = {}
  function e(n) {
    if (r[n]) return r[n].exports
    const i = (r[n] = { i: n, l: !1, exports: {} })
    return t[n].call(i.exports, i, i.exports, e), (i.l = !0), i.exports
  }
  return (
    (e.m = t),
    (e.c = r),
    (e.d = function(t, r, n) {
      e.o(t, r) || Object.defineProperty(t, r, { enumerable: !0, get: n })
    }),
    (e.r = function(t) {
      typeof Symbol !== 'undefined' &&
        Symbol.toStringTag &&
        Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }),
        Object.defineProperty(t, '__esModule', { value: !0 })
    }),
    (e.t = function(t, r) {
      if ((1 & r && (t = e(t)), 8 & r)) return t
      if (4 & r && typeof t === 'object' && t && t.__esModule) return t
      const n = Object.create(null)
      if (
        (e.r(n),
        Object.defineProperty(n, 'default', { enumerable: !0, value: t }),
        2 & r && typeof t !== 'string')
      )
        for (const i in t)
          e.d(
            n,
            i,
            function(r) {
              return t[r]
            }.bind(null, i)
          )
      return n
    }),
    (e.n = function(t) {
      const r =
        t && t.__esModule
          ? function() {
              return t.default
            }
          : function() {
              return t
            }
      return e.d(r, 'a', r), r
    }),
    (e.o = function(t, r) {
      return Object.prototype.hasOwnProperty.call(t, r)
    }),
    (e.p = ''),
    e((e.s = 1))
  )
})([
  function(t, r) {
    t.exports = bsv
  },
  function(t, r, e) {
    t.exports = e(2)
  },
  function(t, r, e) {
    const n = e(0)
    ;(n.Message = e(3)), (t.exports = n.Message)
  },
  function(t, r, e) {
    'use strict'
    ;(function(r) {
      const n = e(0)
      const i = n.deps._
      const o = n.PrivateKey
      const u = n.PublicKey
      const f = n.Address
      const s = n.encoding.BufferWriter
      const a = n.crypto.ECDSA
      const h = n.crypto.Signature
      const c = n.crypto.Hash.sha256sha256
      const l = n.util.js
      const p = n.util.preconditions
      const g = function t(e) {
        return this instanceof t
          ? (p.checkArgument(
              i.isString(e) || r.isBuffer(e),
              'First argument should be a string or Buffer'
            ),
            i.isString(e) && (this.messageBuffer = r.from(e)),
            r.isBuffer(e) && (this.messageBuffer = e),
            this)
          : new t(e)
      }
      ;(g.sign = function(t, r) {
        return new g(t).sign(r)
      }),
        (g.verify = function(t, r, e) {
          return new g(t).verify(r, e)
        }),
        (g.MAGIC_BYTES = r.from('Bitcoin Signed Message:\n')),
        (g.prototype.magicHash = function() {
          const t = s.varintBufNum(g.MAGIC_BYTES.length)
          const e = s.varintBufNum(this.messageBuffer.length)
          const n = r.concat([t, g.MAGIC_BYTES, e, this.messageBuffer])
          return c(n)
        }),
        (g.prototype._sign = function(t) {
          p.checkArgument(
            t instanceof o,
            'First argument should be an instance of PrivateKey'
          )
          const r = this.magicHash()
          return a.signWithCalcI(r, t)
        }),
        (g.prototype.sign = function(t) {
          return this._sign(t)
            .toCompact()
            .toString('base64')
        }),
        (g.prototype._verify = function(t, r) {
          p.checkArgument(
            t instanceof u,
            'First argument should be an instance of PublicKey'
          ),
            p.checkArgument(
              r instanceof h,
              'Second argument should be an instance of Signature'
            )
          const e = this.magicHash()
          const n = a.verify(e, r, t)
          return n || (this.error = 'The signature was invalid'), n
        }),
        (g.prototype.verify = function(t, e) {
          p.checkArgument(t),
            p.checkArgument(e && i.isString(e)),
            i.isString(t) && (t = f.fromString(t))
          const n = h.fromCompact(r.from(e, 'base64'))
          const o = new a()
          ;(o.hashbuf = this.magicHash()), (o.sig = n)
          const u = o.toPublicKey()
          const s = f.fromPublicKey(u, t.network)
          return t.toString() !== s.toString()
            ? ((this.error = 'The signature did not match the message digest'),
              !1)
            : this._verify(u, n)
        }),
        (g.fromString = function(t) {
          return new g(t)
        }),
        (g.fromJSON = function(t) {
          return l.isValidJSON(t) && (t = JSON.parse(t)), g.fromObject(t)
        }),
        (g.prototype.toObject = function() {
          return { messageHex: this.messageBuffer.toString('hex') }
        }),
        (g.fromObject = function(t) {
          const e = r.from(t.messageHex, 'hex')
          return new g(e)
        }),
        (g.prototype.toJSON = function() {
          return JSON.stringify(this.toObject())
        }),
        (g.prototype.toString = function() {
          return this.messageBuffer.toString()
        }),
        (g.prototype.inspect = function() {
          return '<Message: ' + this.toString() + '>'
        }),
        (t.exports = g)
    }.call(this, e(4).Buffer))
  },
  function(t, r, e) {
    'use strict'
    ;(function(t) {
      /*!
       * The buffer module from node.js, for the browser.
       *
       * @author   Feross Aboukhadijeh <http://feross.org>
       * @license  MIT
       */
      const n = e(6)
      const i = e(7)
      const o = e(8)
      function u() {
        return s.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
      }
      function f(t, r) {
        if (u() < r) throw new RangeError('Invalid typed array length')
        return (
          s.TYPED_ARRAY_SUPPORT
            ? ((t = new Uint8Array(r)).__proto__ = s.prototype)
            : (t === null && (t = new s(r)), (t.length = r)),
          t
        )
      }
      function s(t, r, e) {
        if (!(s.TYPED_ARRAY_SUPPORT || this instanceof s)) return new s(t, r, e)
        if (typeof t === 'number') {
          if (typeof r === 'string')
            throw new Error(
              'If encoding is specified then the first argument must be a string'
            )
          return c(this, t)
        }
        return a(this, t, r, e)
      }
      function a(t, r, e, n) {
        if (typeof r === 'number')
          throw new TypeError('"value" argument must not be a number')
        return typeof ArrayBuffer !== 'undefined' && r instanceof ArrayBuffer
          ? (function(t, r, e, n) {
              if ((r.byteLength, e < 0 || r.byteLength < e))
                throw new RangeError("'offset' is out of bounds")
              if (r.byteLength < e + (n || 0))
                throw new RangeError("'length' is out of bounds")
              r =
                void 0 === e && void 0 === n
                  ? new Uint8Array(r)
                  : void 0 === n
                  ? new Uint8Array(r, e)
                  : new Uint8Array(r, e, n)
              s.TYPED_ARRAY_SUPPORT
                ? ((t = r).__proto__ = s.prototype)
                : (t = l(t, r))
              return t
            })(t, r, e, n)
          : typeof r === 'string'
          ? (function(t, r, e) {
              ;(typeof e === 'string' && e !== '') || (e = 'utf8')
              if (!s.isEncoding(e))
                throw new TypeError(
                  '"encoding" must be a valid string encoding'
                )
              const n = 0 | g(r, e)
              const i = (t = f(t, n)).write(r, e)
              i !== n && (t = t.slice(0, i))
              return t
            })(t, r, e)
          : (function(t, r) {
              if (s.isBuffer(r)) {
                const e = 0 | p(r.length)
                return (t = f(t, e)).length === 0 ? t : (r.copy(t, 0, 0, e), t)
              }
              if (r) {
                if (
                  (typeof ArrayBuffer !== 'undefined' &&
                    r.buffer instanceof ArrayBuffer) ||
                  'length' in r
                )
                  return typeof r.length !== 'number' || (n = r.length) != n
                    ? f(t, 0)
                    : l(t, r)
                if (r.type === 'Buffer' && o(r.data)) return l(t, r.data)
              }
              let n
              throw new TypeError(
                'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.'
              )
            })(t, r)
      }
      function h(t) {
        if (typeof t !== 'number')
          throw new TypeError('"size" argument must be a number')
        if (t < 0) throw new RangeError('"size" argument must not be negative')
      }
      function c(t, r) {
        if ((h(r), (t = f(t, r < 0 ? 0 : 0 | p(r))), !s.TYPED_ARRAY_SUPPORT))
          for (let e = 0; e < r; ++e) t[e] = 0
        return t
      }
      function l(t, r) {
        const e = r.length < 0 ? 0 : 0 | p(r.length)
        t = f(t, e)
        for (let n = 0; n < e; n += 1) t[n] = 255 & r[n]
        return t
      }
      function p(t) {
        if (t >= u())
          throw new RangeError(
            'Attempt to allocate Buffer larger than maximum size: 0x' +
              u().toString(16) +
              ' bytes'
          )
        return 0 | t
      }
      function g(t, r) {
        if (s.isBuffer(t)) return t.length
        if (
          typeof ArrayBuffer !== 'undefined' &&
          typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)
        )
          return t.byteLength
        typeof t !== 'string' && (t = '' + t)
        const e = t.length
        if (e === 0) return 0
        for (let n = !1; ; )
          switch (r) {
            case 'ascii':
            case 'latin1':
            case 'binary':
              return e
            case 'utf8':
            case 'utf-8':
            case void 0:
              return F(t).length
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return 2 * e
            case 'hex':
              return e >>> 1
            case 'base64':
              return z(t).length
            default:
              if (n) return F(t).length
              ;(r = ('' + r).toLowerCase()), (n = !0)
          }
      }
      function y(t, r, e) {
        let n = !1
        if (((void 0 === r || r < 0) && (r = 0), r > this.length)) return ''
        if (((void 0 === e || e > this.length) && (e = this.length), e <= 0))
          return ''
        if ((e >>>= 0) <= (r >>>= 0)) return ''
        for (t || (t = 'utf8'); ; )
          switch (t) {
            case 'hex':
              return Y(this, r, e)
            case 'utf8':
            case 'utf-8':
              return B(this, r, e)
            case 'ascii':
              return T(this, r, e)
            case 'latin1':
            case 'binary':
              return U(this, r, e)
            case 'base64':
              return S(this, r, e)
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return O(this, r, e)
            default:
              if (n) throw new TypeError('Unknown encoding: ' + t)
              ;(t = (t + '').toLowerCase()), (n = !0)
          }
      }
      function w(t, r, e) {
        const n = t[r]
        ;(t[r] = t[e]), (t[e] = n)
      }
      function d(t, r, e, n, i) {
        if (t.length === 0) return -1
        if (
          (typeof e === 'string'
            ? ((n = e), (e = 0))
            : e > 2147483647
            ? (e = 2147483647)
            : e < -2147483648 && (e = -2147483648),
          (e = +e),
          isNaN(e) && (e = i ? 0 : t.length - 1),
          e < 0 && (e = t.length + e),
          e >= t.length)
        ) {
          if (i) return -1
          e = t.length - 1
        } else if (e < 0) {
          if (!i) return -1
          e = 0
        }
        if ((typeof r === 'string' && (r = s.from(r, n)), s.isBuffer(r)))
          return r.length === 0 ? -1 : v(t, r, e, n, i)
        if (typeof r === 'number')
          return (
            (r &= 255),
            s.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function'
              ? i
                ? Uint8Array.prototype.indexOf.call(t, r, e)
                : Uint8Array.prototype.lastIndexOf.call(t, r, e)
              : v(t, [r], e, n, i)
          )
        throw new TypeError('val must be string, number or Buffer')
      }
      function v(t, r, e, n, i) {
        let o
        let u = 1
        let f = t.length
        let s = r.length
        if (
          void 0 !== n &&
          ((n = String(n).toLowerCase()) === 'ucs2' ||
            n === 'ucs-2' ||
            n === 'utf16le' ||
            n === 'utf-16le')
        ) {
          if (t.length < 2 || r.length < 2) return -1
          ;(u = 2), (f /= 2), (s /= 2), (e /= 2)
        }
        function a(t, r) {
          return u === 1 ? t[r] : t.readUInt16BE(r * u)
        }
        if (i) {
          let h = -1
          for (o = e; o < f; o++)
            if (a(t, o) === a(r, h === -1 ? 0 : o - h)) {
              if ((h === -1 && (h = o), o - h + 1 === s)) return h * u
            } else h !== -1 && (o -= o - h), (h = -1)
        } else
          for (e + s > f && (e = f - s), o = e; o >= 0; o--) {
            for (var c = !0, l = 0; l < s; l++)
              if (a(t, o + l) !== a(r, l)) {
                c = !1
                break
              }
            if (c) return o
          }
        return -1
      }
      function m(t, r, e, n) {
        e = Number(e) || 0
        const i = t.length - e
        n ? (n = Number(n)) > i && (n = i) : (n = i)
        const o = r.length
        if (o % 2 != 0) throw new TypeError('Invalid hex string')
        n > o / 2 && (n = o / 2)
        for (var u = 0; u < n; ++u) {
          const f = parseInt(r.substr(2 * u, 2), 16)
          if (isNaN(f)) return u
          t[e + u] = f
        }
        return u
      }
      function b(t, r, e, n) {
        return H(F(r, t.length - e), t, e, n)
      }
      function A(t, r, e, n) {
        return H(
          (function(t) {
            for (var r = [], e = 0; e < t.length; ++e)
              r.push(255 & t.charCodeAt(e))
            return r
          })(r),
          t,
          e,
          n
        )
      }
      function E(t, r, e, n) {
        return A(t, r, e, n)
      }
      function _(t, r, e, n) {
        return H(z(r), t, e, n)
      }
      function R(t, r, e, n) {
        return H(
          (function(t, r) {
            for (
              var e, n, i, o = [], u = 0;
              u < t.length && !((r -= 2) < 0);
              ++u
            )
              (e = t.charCodeAt(u)),
                (n = e >> 8),
                (i = e % 256),
                o.push(i),
                o.push(n)
            return o
          })(r, t.length - e),
          t,
          e,
          n
        )
      }
      function S(t, r, e) {
        return r === 0 && e === t.length
          ? n.fromByteArray(t)
          : n.fromByteArray(t.slice(r, e))
      }
      function B(t, r, e) {
        e = Math.min(t.length, e)
        for (var n = [], i = r; i < e; ) {
          var o
          var u
          var f
          var s
          const a = t[i]
          let h = null
          let c = a > 239 ? 4 : a > 223 ? 3 : a > 191 ? 2 : 1
          if (i + c <= e)
            switch (c) {
              case 1:
                a < 128 && (h = a)
                break
              case 2:
                ;(192 & (o = t[i + 1])) == 128 &&
                  (s = ((31 & a) << 6) | (63 & o)) > 127 &&
                  (h = s)
                break
              case 3:
                ;(o = t[i + 1]),
                  (u = t[i + 2]),
                  (192 & o) == 128 &&
                    (192 & u) == 128 &&
                    (s = ((15 & a) << 12) | ((63 & o) << 6) | (63 & u)) >
                      2047 &&
                    (s < 55296 || s > 57343) &&
                    (h = s)
                break
              case 4:
                ;(o = t[i + 1]),
                  (u = t[i + 2]),
                  (f = t[i + 3]),
                  (192 & o) == 128 &&
                    (192 & u) == 128 &&
                    (192 & f) == 128 &&
                    (s =
                      ((15 & a) << 18) |
                      ((63 & o) << 12) |
                      ((63 & u) << 6) |
                      (63 & f)) > 65535 &&
                    s < 1114112 &&
                    (h = s)
            }
          h === null
            ? ((h = 65533), (c = 1))
            : h > 65535 &&
              ((h -= 65536),
              n.push(((h >>> 10) & 1023) | 55296),
              (h = 56320 | (1023 & h))),
            n.push(h),
            (i += c)
        }
        return (function(t) {
          const r = t.length
          if (r <= P) return String.fromCharCode.apply(String, t)
          let e = ''
          let n = 0
          for (; n < r; )
            e += String.fromCharCode.apply(String, t.slice(n, (n += P)))
          return e
        })(n)
      }
      ;(r.Buffer = s),
        (r.SlowBuffer = function(t) {
          ;+t != t && (t = 0)
          return s.alloc(+t)
        }),
        (r.INSPECT_MAX_BYTES = 50),
        (s.TYPED_ARRAY_SUPPORT =
          void 0 !== t.TYPED_ARRAY_SUPPORT
            ? t.TYPED_ARRAY_SUPPORT
            : (function() {
                try {
                  const t = new Uint8Array(1)
                  return (
                    (t.__proto__ = {
                      __proto__: Uint8Array.prototype,
                      foo() {
                        return 42
                      }
                    }),
                    t.foo() === 42 &&
                      typeof t.subarray === 'function' &&
                      t.subarray(1, 1).byteLength === 0
                  )
                } catch (t) {
                  return !1
                }
              })()),
        (r.kMaxLength = u()),
        (s.poolSize = 8192),
        (s._augment = function(t) {
          return (t.__proto__ = s.prototype), t
        }),
        (s.from = function(t, r, e) {
          return a(null, t, r, e)
        }),
        s.TYPED_ARRAY_SUPPORT &&
          ((s.prototype.__proto__ = Uint8Array.prototype),
          (s.__proto__ = Uint8Array),
          typeof Symbol !== 'undefined' &&
            Symbol.species &&
            s[Symbol.species] === s &&
            Object.defineProperty(s, Symbol.species, {
              value: null,
              configurable: !0
            })),
        (s.alloc = function(t, r, e) {
          return (function(t, r, e, n) {
            return (
              h(r),
              r <= 0
                ? f(t, r)
                : void 0 !== e
                ? typeof n === 'string'
                  ? f(t, r).fill(e, n)
                  : f(t, r).fill(e)
                : f(t, r)
            )
          })(null, t, r, e)
        }),
        (s.allocUnsafe = function(t) {
          return c(null, t)
        }),
        (s.allocUnsafeSlow = function(t) {
          return c(null, t)
        }),
        (s.isBuffer = function(t) {
          return !(t == null || !t._isBuffer)
        }),
        (s.compare = function(t, r) {
          if (!s.isBuffer(t) || !s.isBuffer(r))
            throw new TypeError('Arguments must be Buffers')
          if (t === r) return 0
          for (
            var e = t.length, n = r.length, i = 0, o = Math.min(e, n);
            i < o;
            ++i
          )
            if (t[i] !== r[i]) {
              ;(e = t[i]), (n = r[i])
              break
            }
          return e < n ? -1 : n < e ? 1 : 0
        }),
        (s.isEncoding = function(t) {
          switch (String(t).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return !0
            default:
              return !1
          }
        }),
        (s.concat = function(t, r) {
          if (!o(t))
            throw new TypeError('"list" argument must be an Array of Buffers')
          if (t.length === 0) return s.alloc(0)
          let e
          if (void 0 === r)
            for (r = 0, e = 0; e < t.length; ++e) r += t[e].length
          const n = s.allocUnsafe(r)
          let i = 0
          for (e = 0; e < t.length; ++e) {
            const u = t[e]
            if (!s.isBuffer(u))
              throw new TypeError('"list" argument must be an Array of Buffers')
            u.copy(n, i), (i += u.length)
          }
          return n
        }),
        (s.byteLength = g),
        (s.prototype._isBuffer = !0),
        (s.prototype.swap16 = function() {
          const t = this.length
          if (t % 2 != 0)
            throw new RangeError('Buffer size must be a multiple of 16-bits')
          for (let r = 0; r < t; r += 2) w(this, r, r + 1)
          return this
        }),
        (s.prototype.swap32 = function() {
          const t = this.length
          if (t % 4 != 0)
            throw new RangeError('Buffer size must be a multiple of 32-bits')
          for (let r = 0; r < t; r += 4)
            w(this, r, r + 3), w(this, r + 1, r + 2)
          return this
        }),
        (s.prototype.swap64 = function() {
          const t = this.length
          if (t % 8 != 0)
            throw new RangeError('Buffer size must be a multiple of 64-bits')
          for (let r = 0; r < t; r += 8)
            w(this, r, r + 7),
              w(this, r + 1, r + 6),
              w(this, r + 2, r + 5),
              w(this, r + 3, r + 4)
          return this
        }),
        (s.prototype.toString = function() {
          const t = 0 | this.length
          return t === 0
            ? ''
            : arguments.length === 0
            ? B(this, 0, t)
            : y.apply(this, arguments)
        }),
        (s.prototype.equals = function(t) {
          if (!s.isBuffer(t)) throw new TypeError('Argument must be a Buffer')
          return this === t || s.compare(this, t) === 0
        }),
        (s.prototype.inspect = function() {
          let t = ''
          const e = r.INSPECT_MAX_BYTES
          return (
            this.length > 0 &&
              ((t = this.toString('hex', 0, e)
                .match(/.{2}/g)
                .join(' ')),
              this.length > e && (t += ' ... ')),
            '<Buffer ' + t + '>'
          )
        }),
        (s.prototype.compare = function(t, r, e, n, i) {
          if (!s.isBuffer(t)) throw new TypeError('Argument must be a Buffer')
          if (
            (void 0 === r && (r = 0),
            void 0 === e && (e = t ? t.length : 0),
            void 0 === n && (n = 0),
            void 0 === i && (i = this.length),
            r < 0 || e > t.length || n < 0 || i > this.length)
          )
            throw new RangeError('out of range index')
          if (n >= i && r >= e) return 0
          if (n >= i) return -1
          if (r >= e) return 1
          if (this === t) return 0
          for (
            var o = (i >>>= 0) - (n >>>= 0),
              u = (e >>>= 0) - (r >>>= 0),
              f = Math.min(o, u),
              a = this.slice(n, i),
              h = t.slice(r, e),
              c = 0;
            c < f;
            ++c
          )
            if (a[c] !== h[c]) {
              ;(o = a[c]), (u = h[c])
              break
            }
          return o < u ? -1 : u < o ? 1 : 0
        }),
        (s.prototype.includes = function(t, r, e) {
          return this.includes(t)
        }),
        (s.prototype.indexOf = function(t, r, e) {
          return d(this, t, r, e, !0)
        }),
        (s.prototype.lastIndexOf = function(t, r, e) {
          return d(this, t, r, e, !1)
        }),
        (s.prototype.write = function(t, r, e, n) {
          if (void 0 === r) (n = 'utf8'), (e = this.length), (r = 0)
          else if (void 0 === e && typeof r === 'string')
            (n = r), (e = this.length), (r = 0)
          else {
            if (!isFinite(r))
              throw new Error(
                'Buffer.write(string, encoding, offset[, length]) is no longer supported'
              )
            ;(r |= 0),
              isFinite(e)
                ? ((e |= 0), void 0 === n && (n = 'utf8'))
                : ((n = e), (e = void 0))
          }
          const i = this.length - r
          if (
            ((void 0 === e || e > i) && (e = i),
            (t.length > 0 && (e < 0 || r < 0)) || r > this.length)
          )
            throw new RangeError('Attempt to write outside buffer bounds')
          n || (n = 'utf8')
          for (let o = !1; ; )
            switch (n) {
              case 'hex':
                return m(this, t, r, e)
              case 'utf8':
              case 'utf-8':
                return b(this, t, r, e)
              case 'ascii':
                return A(this, t, r, e)
              case 'latin1':
              case 'binary':
                return E(this, t, r, e)
              case 'base64':
                return _(this, t, r, e)
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return R(this, t, r, e)
              default:
                if (o) throw new TypeError('Unknown encoding: ' + n)
                ;(n = ('' + n).toLowerCase()), (o = !0)
            }
        }),
        (s.prototype.toJSON = function() {
          return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0)
          }
        })
      var P = 4096
      function T(t, r, e) {
        let n = ''
        e = Math.min(t.length, e)
        for (let i = r; i < e; ++i) n += String.fromCharCode(127 & t[i])
        return n
      }
      function U(t, r, e) {
        let n = ''
        e = Math.min(t.length, e)
        for (let i = r; i < e; ++i) n += String.fromCharCode(t[i])
        return n
      }
      function Y(t, r, e) {
        const n = t.length
        ;(!r || r < 0) && (r = 0), (!e || e < 0 || e > n) && (e = n)
        for (var i = '', o = r; o < e; ++o) i += j(t[o])
        return i
      }
      function O(t, r, e) {
        for (var n = t.slice(r, e), i = '', o = 0; o < n.length; o += 2)
          i += String.fromCharCode(n[o] + 256 * n[o + 1])
        return i
      }
      function I(t, r, e) {
        if (t % 1 != 0 || t < 0) throw new RangeError('offset is not uint')
        if (t + r > e)
          throw new RangeError('Trying to access beyond buffer length')
      }
      function M(t, r, e, n, i, o) {
        if (!s.isBuffer(t))
          throw new TypeError('"buffer" argument must be a Buffer instance')
        if (r > i || r < o)
          throw new RangeError('"value" argument is out of bounds')
        if (e + n > t.length) throw new RangeError('Index out of range')
      }
      function C(t, r, e, n) {
        r < 0 && (r = 65535 + r + 1)
        for (let i = 0, o = Math.min(t.length - e, 2); i < o; ++i)
          t[e + i] =
            (r & (255 << (8 * (n ? i : 1 - i)))) >>> (8 * (n ? i : 1 - i))
      }
      function x(t, r, e, n) {
        r < 0 && (r = 4294967295 + r + 1)
        for (let i = 0, o = Math.min(t.length - e, 4); i < o; ++i)
          t[e + i] = (r >>> (8 * (n ? i : 3 - i))) & 255
      }
      function L(t, r, e, n, i, o) {
        if (e + n > t.length) throw new RangeError('Index out of range')
        if (e < 0) throw new RangeError('Index out of range')
      }
      function D(t, r, e, n, o) {
        return o || L(t, 0, e, 4), i.write(t, r, e, n, 23, 4), e + 4
      }
      function N(t, r, e, n, o) {
        return o || L(t, 0, e, 8), i.write(t, r, e, n, 52, 8), e + 8
      }
      ;(s.prototype.slice = function(t, r) {
        let e
        const n = this.length
        if (
          ((t = ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n),
          (r = void 0 === r ? n : ~~r) < 0
            ? (r += n) < 0 && (r = 0)
            : r > n && (r = n),
          r < t && (r = t),
          s.TYPED_ARRAY_SUPPORT)
        )
          (e = this.subarray(t, r)).__proto__ = s.prototype
        else {
          const i = r - t
          e = new s(i, void 0)
          for (let o = 0; o < i; ++o) e[o] = this[o + t]
        }
        return e
      }),
        (s.prototype.readUIntLE = function(t, r, e) {
          ;(t |= 0), (r |= 0), e || I(t, r, this.length)
          for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256); )
            n += this[t + o] * i
          return n
        }),
        (s.prototype.readUIntBE = function(t, r, e) {
          ;(t |= 0), (r |= 0), e || I(t, r, this.length)
          for (var n = this[t + --r], i = 1; r > 0 && (i *= 256); )
            n += this[t + --r] * i
          return n
        }),
        (s.prototype.readUInt8 = function(t, r) {
          return r || I(t, 1, this.length), this[t]
        }),
        (s.prototype.readUInt16LE = function(t, r) {
          return r || I(t, 2, this.length), this[t] | (this[t + 1] << 8)
        }),
        (s.prototype.readUInt16BE = function(t, r) {
          return r || I(t, 2, this.length), (this[t] << 8) | this[t + 1]
        }),
        (s.prototype.readUInt32LE = function(t, r) {
          return (
            r || I(t, 4, this.length),
            (this[t] | (this[t + 1] << 8) | (this[t + 2] << 16)) +
              16777216 * this[t + 3]
          )
        }),
        (s.prototype.readUInt32BE = function(t, r) {
          return (
            r || I(t, 4, this.length),
            16777216 * this[t] +
              ((this[t + 1] << 16) | (this[t + 2] << 8) | this[t + 3])
          )
        }),
        (s.prototype.readIntLE = function(t, r, e) {
          ;(t |= 0), (r |= 0), e || I(t, r, this.length)
          for (var n = this[t], i = 1, o = 0; ++o < r && (i *= 256); )
            n += this[t + o] * i
          return n >= (i *= 128) && (n -= 2 ** (8 * r)), n
        }),
        (s.prototype.readIntBE = function(t, r, e) {
          ;(t |= 0), (r |= 0), e || I(t, r, this.length)
          for (var n = r, i = 1, o = this[t + --n]; n > 0 && (i *= 256); )
            o += this[t + --n] * i
          return o >= (i *= 128) && (o -= 2 ** (8 * r)), o
        }),
        (s.prototype.readInt8 = function(t, r) {
          return (
            r || I(t, 1, this.length),
            128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
          )
        }),
        (s.prototype.readInt16LE = function(t, r) {
          r || I(t, 2, this.length)
          const e = this[t] | (this[t + 1] << 8)
          return 32768 & e ? 4294901760 | e : e
        }),
        (s.prototype.readInt16BE = function(t, r) {
          r || I(t, 2, this.length)
          const e = this[t + 1] | (this[t] << 8)
          return 32768 & e ? 4294901760 | e : e
        }),
        (s.prototype.readInt32LE = function(t, r) {
          return (
            r || I(t, 4, this.length),
            this[t] |
              (this[t + 1] << 8) |
              (this[t + 2] << 16) |
              (this[t + 3] << 24)
          )
        }),
        (s.prototype.readInt32BE = function(t, r) {
          return (
            r || I(t, 4, this.length),
            (this[t] << 24) |
              (this[t + 1] << 16) |
              (this[t + 2] << 8) |
              this[t + 3]
          )
        }),
        (s.prototype.readFloatLE = function(t, r) {
          return r || I(t, 4, this.length), i.read(this, t, !0, 23, 4)
        }),
        (s.prototype.readFloatBE = function(t, r) {
          return r || I(t, 4, this.length), i.read(this, t, !1, 23, 4)
        }),
        (s.prototype.readDoubleLE = function(t, r) {
          return r || I(t, 8, this.length), i.read(this, t, !0, 52, 8)
        }),
        (s.prototype.readDoubleBE = function(t, r) {
          return r || I(t, 8, this.length), i.read(this, t, !1, 52, 8)
        }),
        (s.prototype.writeUIntLE = function(t, r, e, n) {
          ;((t = +t), (r |= 0), (e |= 0), n) ||
            M(this, t, r, e, 2 ** (8 * e) - 1, 0)
          let i = 1
          let o = 0
          for (this[r] = 255 & t; ++o < e && (i *= 256); )
            this[r + o] = (t / i) & 255
          return r + e
        }),
        (s.prototype.writeUIntBE = function(t, r, e, n) {
          ;((t = +t), (r |= 0), (e |= 0), n) ||
            M(this, t, r, e, 2 ** (8 * e) - 1, 0)
          let i = e - 1
          let o = 1
          for (this[r + i] = 255 & t; --i >= 0 && (o *= 256); )
            this[r + i] = (t / o) & 255
          return r + e
        }),
        (s.prototype.writeUInt8 = function(t, r, e) {
          return (
            (t = +t),
            (r |= 0),
            e || M(this, t, r, 1, 255, 0),
            s.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
            (this[r] = 255 & t),
            r + 1
          )
        }),
        (s.prototype.writeUInt16LE = function(t, r, e) {
          return (
            (t = +t),
            (r |= 0),
            e || M(this, t, r, 2, 65535, 0),
            s.TYPED_ARRAY_SUPPORT
              ? ((this[r] = 255 & t), (this[r + 1] = t >>> 8))
              : C(this, t, r, !0),
            r + 2
          )
        }),
        (s.prototype.writeUInt16BE = function(t, r, e) {
          return (
            (t = +t),
            (r |= 0),
            e || M(this, t, r, 2, 65535, 0),
            s.TYPED_ARRAY_SUPPORT
              ? ((this[r] = t >>> 8), (this[r + 1] = 255 & t))
              : C(this, t, r, !1),
            r + 2
          )
        }),
        (s.prototype.writeUInt32LE = function(t, r, e) {
          return (
            (t = +t),
            (r |= 0),
            e || M(this, t, r, 4, 4294967295, 0),
            s.TYPED_ARRAY_SUPPORT
              ? ((this[r + 3] = t >>> 24),
                (this[r + 2] = t >>> 16),
                (this[r + 1] = t >>> 8),
                (this[r] = 255 & t))
              : x(this, t, r, !0),
            r + 4
          )
        }),
        (s.prototype.writeUInt32BE = function(t, r, e) {
          return (
            (t = +t),
            (r |= 0),
            e || M(this, t, r, 4, 4294967295, 0),
            s.TYPED_ARRAY_SUPPORT
              ? ((this[r] = t >>> 24),
                (this[r + 1] = t >>> 16),
                (this[r + 2] = t >>> 8),
                (this[r + 3] = 255 & t))
              : x(this, t, r, !1),
            r + 4
          )
        }),
        (s.prototype.writeIntLE = function(t, r, e, n) {
          if (((t = +t), (r |= 0), !n)) {
            const i = 2 ** (8 * e - 1)
            M(this, t, r, e, i - 1, -i)
          }
          let o = 0
          let u = 1
          let f = 0
          for (this[r] = 255 & t; ++o < e && (u *= 256); )
            t < 0 && f === 0 && this[r + o - 1] !== 0 && (f = 1),
              (this[r + o] = (((t / u) >> 0) - f) & 255)
          return r + e
        }),
        (s.prototype.writeIntBE = function(t, r, e, n) {
          if (((t = +t), (r |= 0), !n)) {
            const i = 2 ** (8 * e - 1)
            M(this, t, r, e, i - 1, -i)
          }
          let o = e - 1
          let u = 1
          let f = 0
          for (this[r + o] = 255 & t; --o >= 0 && (u *= 256); )
            t < 0 && f === 0 && this[r + o + 1] !== 0 && (f = 1),
              (this[r + o] = (((t / u) >> 0) - f) & 255)
          return r + e
        }),
        (s.prototype.writeInt8 = function(t, r, e) {
          return (
            (t = +t),
            (r |= 0),
            e || M(this, t, r, 1, 127, -128),
            s.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)),
            t < 0 && (t = 255 + t + 1),
            (this[r] = 255 & t),
            r + 1
          )
        }),
        (s.prototype.writeInt16LE = function(t, r, e) {
          return (
            (t = +t),
            (r |= 0),
            e || M(this, t, r, 2, 32767, -32768),
            s.TYPED_ARRAY_SUPPORT
              ? ((this[r] = 255 & t), (this[r + 1] = t >>> 8))
              : C(this, t, r, !0),
            r + 2
          )
        }),
        (s.prototype.writeInt16BE = function(t, r, e) {
          return (
            (t = +t),
            (r |= 0),
            e || M(this, t, r, 2, 32767, -32768),
            s.TYPED_ARRAY_SUPPORT
              ? ((this[r] = t >>> 8), (this[r + 1] = 255 & t))
              : C(this, t, r, !1),
            r + 2
          )
        }),
        (s.prototype.writeInt32LE = function(t, r, e) {
          return (
            (t = +t),
            (r |= 0),
            e || M(this, t, r, 4, 2147483647, -2147483648),
            s.TYPED_ARRAY_SUPPORT
              ? ((this[r] = 255 & t),
                (this[r + 1] = t >>> 8),
                (this[r + 2] = t >>> 16),
                (this[r + 3] = t >>> 24))
              : x(this, t, r, !0),
            r + 4
          )
        }),
        (s.prototype.writeInt32BE = function(t, r, e) {
          return (
            (t = +t),
            (r |= 0),
            e || M(this, t, r, 4, 2147483647, -2147483648),
            t < 0 && (t = 4294967295 + t + 1),
            s.TYPED_ARRAY_SUPPORT
              ? ((this[r] = t >>> 24),
                (this[r + 1] = t >>> 16),
                (this[r + 2] = t >>> 8),
                (this[r + 3] = 255 & t))
              : x(this, t, r, !1),
            r + 4
          )
        }),
        (s.prototype.writeFloatLE = function(t, r, e) {
          return D(this, t, r, !0, e)
        }),
        (s.prototype.writeFloatBE = function(t, r, e) {
          return D(this, t, r, !1, e)
        }),
        (s.prototype.writeDoubleLE = function(t, r, e) {
          return N(this, t, r, !0, e)
        }),
        (s.prototype.writeDoubleBE = function(t, r, e) {
          return N(this, t, r, !1, e)
        }),
        (s.prototype.copy = function(t, r, e, n) {
          if (
            (e || (e = 0),
            n || n === 0 || (n = this.length),
            r >= t.length && (r = t.length),
            r || (r = 0),
            n > 0 && n < e && (n = e),
            n === e)
          )
            return 0
          if (t.length === 0 || this.length === 0) return 0
          if (r < 0) throw new RangeError('targetStart out of bounds')
          if (e < 0 || e >= this.length)
            throw new RangeError('sourceStart out of bounds')
          if (n < 0) throw new RangeError('sourceEnd out of bounds')
          n > this.length && (n = this.length),
            t.length - r < n - e && (n = t.length - r + e)
          let i
          const o = n - e
          if (this === t && e < r && r < n)
            for (i = o - 1; i >= 0; --i) t[i + r] = this[i + e]
          else if (o < 1e3 || !s.TYPED_ARRAY_SUPPORT)
            for (i = 0; i < o; ++i) t[i + r] = this[i + e]
          else Uint8Array.prototype.set.call(t, this.subarray(e, e + o), r)
          return o
        }),
        (s.prototype.fill = function(t, r, e, n) {
          if (typeof t === 'string') {
            if (
              (typeof r === 'string'
                ? ((n = r), (r = 0), (e = this.length))
                : typeof e === 'string' && ((n = e), (e = this.length)),
              t.length === 1)
            ) {
              const i = t.charCodeAt(0)
              i < 256 && (t = i)
            }
            if (void 0 !== n && typeof n !== 'string')
              throw new TypeError('encoding must be a string')
            if (typeof n === 'string' && !s.isEncoding(n))
              throw new TypeError('Unknown encoding: ' + n)
          } else typeof t === 'number' && (t &= 255)
          if (r < 0 || this.length < r || this.length < e)
            throw new RangeError('Out of range index')
          if (e <= r) return this
          let o
          if (
            ((r >>>= 0),
            (e = void 0 === e ? this.length : e >>> 0),
            t || (t = 0),
            typeof t === 'number')
          )
            for (o = r; o < e; ++o) this[o] = t
          else {
            const u = s.isBuffer(t) ? t : F(new s(t, n).toString())
            const f = u.length
            for (o = 0; o < e - r; ++o) this[o + r] = u[o % f]
          }
          return this
        })
      const k = /[^+\/0-9A-Za-z-_]/g
      function j(t) {
        return t < 16 ? '0' + t.toString(16) : t.toString(16)
      }
      function F(t, r) {
        let e
        r = r || 1 / 0
        for (var n = t.length, i = null, o = [], u = 0; u < n; ++u) {
          if ((e = t.charCodeAt(u)) > 55295 && e < 57344) {
            if (!i) {
              if (e > 56319) {
                ;(r -= 3) > -1 && o.push(239, 191, 189)
                continue
              }
              if (u + 1 === n) {
                ;(r -= 3) > -1 && o.push(239, 191, 189)
                continue
              }
              i = e
              continue
            }
            if (e < 56320) {
              ;(r -= 3) > -1 && o.push(239, 191, 189), (i = e)
              continue
            }
            e = 65536 + (((i - 55296) << 10) | (e - 56320))
          } else i && (r -= 3) > -1 && o.push(239, 191, 189)
          if (((i = null), e < 128)) {
            if ((r -= 1) < 0) break
            o.push(e)
          } else if (e < 2048) {
            if ((r -= 2) < 0) break
            o.push((e >> 6) | 192, (63 & e) | 128)
          } else if (e < 65536) {
            if ((r -= 3) < 0) break
            o.push((e >> 12) | 224, ((e >> 6) & 63) | 128, (63 & e) | 128)
          } else {
            if (!(e < 1114112)) throw new Error('Invalid code point')
            if ((r -= 4) < 0) break
            o.push(
              (e >> 18) | 240,
              ((e >> 12) & 63) | 128,
              ((e >> 6) & 63) | 128,
              (63 & e) | 128
            )
          }
        }
        return o
      }
      function z(t) {
        return n.toByteArray(
          (function(t) {
            if (
              (t = (function(t) {
                return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, '')
              })(t).replace(k, '')).length < 2
            )
              return ''
            for (; t.length % 4 != 0; ) t += '='
            return t
          })(t)
        )
      }
      function H(t, r, e, n) {
        for (var i = 0; i < n && !(i + e >= r.length || i >= t.length); ++i)
          r[i + e] = t[i]
        return i
      }
    }.call(this, e(5)))
  },
  function(t, r) {
    let e
    e = (function() {
      return this
    })()
    try {
      e = e || new Function('return this')()
    } catch (t) {
      typeof window === 'object' && (e = window)
    }
    t.exports = e
  },
  function(t, r, e) {
    'use strict'
    ;(r.byteLength = function(t) {
      const r = a(t)
      const e = r[0]
      const n = r[1]
      return (3 * (e + n)) / 4 - n
    }),
      (r.toByteArray = function(t) {
        let r
        let e
        const n = a(t)
        const u = n[0]
        const f = n[1]
        const s = new o(
          (function(t, r, e) {
            return (3 * (r + e)) / 4 - e
          })(0, u, f)
        )
        let h = 0
        const c = f > 0 ? u - 4 : u
        for (e = 0; e < c; e += 4)
          (r =
            (i[t.charCodeAt(e)] << 18) |
            (i[t.charCodeAt(e + 1)] << 12) |
            (i[t.charCodeAt(e + 2)] << 6) |
            i[t.charCodeAt(e + 3)]),
            (s[h++] = (r >> 16) & 255),
            (s[h++] = (r >> 8) & 255),
            (s[h++] = 255 & r)
        f === 2 &&
          ((r = (i[t.charCodeAt(e)] << 2) | (i[t.charCodeAt(e + 1)] >> 4)),
          (s[h++] = 255 & r))
        f === 1 &&
          ((r =
            (i[t.charCodeAt(e)] << 10) |
            (i[t.charCodeAt(e + 1)] << 4) |
            (i[t.charCodeAt(e + 2)] >> 2)),
          (s[h++] = (r >> 8) & 255),
          (s[h++] = 255 & r))
        return s
      }),
      (r.fromByteArray = function(t) {
        for (
          var r, e = t.length, i = e % 3, o = [], u = 0, f = e - i;
          u < f;
          u += 16383
        )
          o.push(h(t, u, u + 16383 > f ? f : u + 16383))
        i === 1
          ? ((r = t[e - 1]), o.push(n[r >> 2] + n[(r << 4) & 63] + '=='))
          : i === 2 &&
            ((r = (t[e - 2] << 8) + t[e - 1]),
            o.push(n[r >> 10] + n[(r >> 4) & 63] + n[(r << 2) & 63] + '='))
        return o.join('')
      })
    for (
      var n = [],
        i = [],
        o = typeof Uint8Array !== 'undefined' ? Uint8Array : Array,
        u = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        f = 0,
        s = u.length;
      f < s;
      ++f
    )
      (n[f] = u[f]), (i[u.charCodeAt(f)] = f)
    function a(t) {
      const r = t.length
      if (r % 4 > 0)
        throw new Error('Invalid string. Length must be a multiple of 4')
      let e = t.indexOf('=')
      return e === -1 && (e = r), [e, e === r ? 0 : 4 - (e % 4)]
    }
    function h(t, r, e) {
      for (var i, o, u = [], f = r; f < e; f += 3)
        (i =
          ((t[f] << 16) & 16711680) +
          ((t[f + 1] << 8) & 65280) +
          (255 & t[f + 2])),
          u.push(
            n[((o = i) >> 18) & 63] +
              n[(o >> 12) & 63] +
              n[(o >> 6) & 63] +
              n[63 & o]
          )
      return u.join('')
    }
    ;(i['-'.charCodeAt(0)] = 62), (i['_'.charCodeAt(0)] = 63)
  },
  function(t, r) {
    ;(r.read = function(t, r, e, n, i) {
      let o
      let u
      const f = 8 * i - n - 1
      const s = (1 << f) - 1
      const a = s >> 1
      let h = -7
      let c = e ? i - 1 : 0
      const l = e ? -1 : 1
      let p = t[r + c]
      for (
        c += l, o = p & ((1 << -h) - 1), p >>= -h, h += f;
        h > 0;
        o = 256 * o + t[r + c], c += l, h -= 8
      );
      for (
        u = o & ((1 << -h) - 1), o >>= -h, h += n;
        h > 0;
        u = 256 * u + t[r + c], c += l, h -= 8
      );
      if (o === 0) o = 1 - a
      else {
        if (o === s) return u ? NaN : (1 / 0) * (p ? -1 : 1)
        ;(u += 2 ** n), (o -= a)
      }
      return (p ? -1 : 1) * u * 2 ** (o - n)
    }),
      (r.write = function(t, r, e, n, i, o) {
        let u
        let f
        let s
        let a = 8 * o - i - 1
        const h = (1 << a) - 1
        const c = h >> 1
        const l = i === 23 ? 2 ** -24 - 2 ** -77 : 0
        let p = n ? 0 : o - 1
        const g = n ? 1 : -1
        const y = r < 0 || (r === 0 && 1 / r < 0) ? 1 : 0
        for (
          r = Math.abs(r),
            isNaN(r) || r === 1 / 0
              ? ((f = isNaN(r) ? 1 : 0), (u = h))
              : ((u = Math.floor(Math.log(r) / Math.LN2)),
                r * (s = 2 ** -u) < 1 && (u--, (s *= 2)),
                (r += u + c >= 1 ? l / s : l * 2 ** (1 - c)) * s >= 2 &&
                  (u++, (s /= 2)),
                u + c >= h
                  ? ((f = 0), (u = h))
                  : u + c >= 1
                  ? ((f = (r * s - 1) * 2 ** i), (u += c))
                  : ((f = r * 2 ** (c - 1) * 2 ** i), (u = 0)));
          i >= 8;
          t[e + p] = 255 & f, p += g, f /= 256, i -= 8
        );
        for (
          u = (u << i) | f, a += i;
          a > 0;
          t[e + p] = 255 & u, p += g, u /= 256, a -= 8
        );
        t[e + p - g] |= 128 * y
      })
  },
  function(t, r) {
    const e = {}.toString
    t.exports =
      Array.isArray ||
      function(t) {
        return e.call(t) == '[object Array]'
      }
  }
])
